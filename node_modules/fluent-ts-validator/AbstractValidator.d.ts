import { CommonValidatorBuilder, DateValidatorBuilder, IterableValidatorBuilder, NumberValidatorBuilder, SizedIterableValidatorBuilder, StringValidatorBuilder, TypeValidatorBuilder } from "./builder";
import { Validatable, ValidationResult } from "./shared";
import { SizedIterable } from "./shared/SizedIterable";
import { StringValidationOptionsBuilder } from "./builder/StringValidationOptionsBuilder";
import { IterableValidationOptionsBuilder } from "./builder/IterableValidationOptionsBuilder";
/**
 * Abstract base class for all custom validators.
 *
 * @export
 * @abstract
 * @class AbstractValidator
 * @template T - type to validate
 */
export declare abstract class AbstractValidator<T> implements Validatable<T> {
    private rules;
    /**
     * Entry point for defining validation rules independent of a property's type.
     *
     * @param lambdaExpression
     * @returns {CommonValidatorBuilder}
     */
    protected validateIf<TProperty>(lambdaExpression: (input: T) => TProperty | undefined): CommonValidatorBuilder<T, TProperty>;
    /**
     * Entry point for defining validation rules for properties of type any.
     *
     * @param lambdaExpression
     * @returns {TypeValidatorBuilder}
     */
    protected validateIfAny(lambdaExpression: (input: T) => any | undefined): TypeValidatorBuilder<T>;
    /**
     * Entry point for defining validation rules for properties of type number.
     *
     * @param lambdaExpression
     * @returns {NumberValidatorBuilder}
     */
    protected validateIfNumber(lambdaExpression: (input: T) => number | undefined): NumberValidatorBuilder<T>;
    /**
     * Entry point for defining validation rules for properties of type date.
     *
     * @param lambdaExpression
     * @returns {DateValidatorBuilder}
     */
    protected validateIfDate(lambdaExpression: (input: T) => Date | undefined): DateValidatorBuilder<T>;
    /**
     * Entry point for defining validation rules for properties of type string.
     *
     * @param lambdaExpression
     * @returns {StringValidatorBuilder}
     */
    protected validateIfString(lambdaExpression: (input: T) => string | undefined): StringValidatorBuilder<T> & StringValidationOptionsBuilder<T>;
    /**
     * Entry point for defining validation rules that apply to each element of an iterable, independent of the elements' type.
     *
     * @param lambdaExpression
     * @returns {CommonValidatorBuilder}
     */
    protected validateIfEach<TProperty>(lambdaExpression: (input: T) => Iterable<TProperty> | undefined): CommonValidatorBuilder<T, TProperty>;
    /**
     * Entry point for defining validation rules that apply to each element (of type any) of an iterable.
     *
     * @param lambdaExpression
     * @returns {TypeValidatorBuilder}
     */
    protected validateIfEachAny(lambdaExpression: (input: T) => Iterable<any> | undefined): TypeValidatorBuilder<T>;
    /**
     * Entry point for defining validation rules that apply to each element (of type number) of an iterable.
     *
     * @param lambdaExpression
     * @returns {NumberValidatorBuilder}
     */
    protected validateIfEachNumber(lambdaExpression: (input: T) => Iterable<number> | undefined): NumberValidatorBuilder<T>;
    /**
     * Entry point for defining validation rules that apply to each element (of type Date) of an iterable.
     *
     * @param lambdaExpression
     * @returns {DateValidatorBuilder}
     */
    protected validateIfEachDate(lambdaExpression: (input: T) => Iterable<Date> | undefined): DateValidatorBuilder<T>;
    /**
     * Entry point for defining validation rules that apply to each element (of type string) of an iterable.
     *
     * @param lambdaExpression
     * @returns {StringValidatorBuilder}
     */
    protected validateIfEachString(lambdaExpression: (input: T) => Iterable<string> | undefined): StringValidatorBuilder<T> & StringValidationOptionsBuilder<T>;
    /**
     * Entry point for defining validation rules for properties of type Iterable.
     *
     * @param lambdaExpression
     */
    protected validateIfIterable<TProperty>(lambdaExpression: (input: T) => SizedIterable<TProperty> | undefined): SizedIterableValidatorBuilder<T, TProperty> & IterableValidationOptionsBuilder<T>;
    protected validateIfIterable<TProperty>(lambdaExpression: (input: T) => Iterable<TProperty> | undefined): IterableValidatorBuilder<T, TProperty> & IterableValidationOptionsBuilder<T>;
    private registerRule<TProperty>(validationRule);
    /**
     * Synchronously validates the given input.
     *
     * Based on the rules defined in the constructor of the specific validator the validation is performed .
     *
     * @param input - the object to validate
     * @returns {ValidationResult}
     */
    validate(input: T): ValidationResult;
    /**
     * Asynchronously validates the given input.
     *
     * Based on the rules defined in the constructor of the specific validator the validation is performed .
     *
     * @param input - the object to validate
     * @returns {Promise<ValidationResult>}
     */
    validateAsync(input: T): Promise<ValidationResult>;
    private createPromiseForEachRule(input, rules);
    private applyRuleAsync(rule, input);
    private buildValidationResultFrom(outcomes);
}
