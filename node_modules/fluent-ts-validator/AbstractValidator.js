"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const builder_1 = require("./builder");
const shared_1 = require("./shared");
const validation_1 = require("./validation");
/**
 * Abstract base class for all custom validators.
 *
 * @export
 * @abstract
 * @class AbstractValidator
 * @template T - type to validate
 */
class AbstractValidator {
    constructor() {
        this.rules = [];
    }
    /**
     * Entry point for defining validation rules independent of a property's type.
     *
     * @param lambdaExpression
     * @returns {CommonValidatorBuilder}
     */
    validateIf(lambdaExpression) {
        const rule = this.registerRule(new validation_1.ValidationRule(lambdaExpression));
        return new builder_1.CommonValidatorBuilderImpl(rule);
    }
    /**
     * Entry point for defining validation rules for properties of type any.
     *
     * @param lambdaExpression
     * @returns {TypeValidatorBuilder}
     */
    validateIfAny(lambdaExpression) {
        const rule = this.registerRule(new validation_1.ValidationRule(lambdaExpression));
        return new builder_1.TypeValidatorBuilderImpl(rule);
    }
    /**
     * Entry point for defining validation rules for properties of type number.
     *
     * @param lambdaExpression
     * @returns {NumberValidatorBuilder}
     */
    validateIfNumber(lambdaExpression) {
        const rule = this.registerRule(new validation_1.ValidationRule(lambdaExpression));
        return new builder_1.NumberValidatorBuilderImpl(rule);
    }
    /**
     * Entry point for defining validation rules for properties of type date.
     *
     * @param lambdaExpression
     * @returns {DateValidatorBuilder}
     */
    validateIfDate(lambdaExpression) {
        const rule = this.registerRule(new validation_1.ValidationRule(lambdaExpression));
        return new builder_1.DateValidatorBuilderImpl(rule);
    }
    /**
     * Entry point for defining validation rules for properties of type string.
     *
     * @param lambdaExpression
     * @returns {StringValidatorBuilder}
     */
    validateIfString(lambdaExpression) {
        const rule = this.registerRule(new validation_1.ValidationRule(lambdaExpression));
        return new builder_1.StringValidatorBuilderImpl(rule);
    }
    /**
     * Entry point for defining validation rules that apply to each element of an iterable, independent of the elements' type.
     *
     * @param lambdaExpression
     * @returns {CommonValidatorBuilder}
     */
    validateIfEach(lambdaExpression) {
        const rule = this.registerRule(new validation_1.CollectionValidationRule(lambdaExpression));
        return new builder_1.CommonValidatorBuilderImpl(rule);
    }
    /**
     * Entry point for defining validation rules that apply to each element (of type any) of an iterable.
     *
     * @param lambdaExpression
     * @returns {TypeValidatorBuilder}
     */
    validateIfEachAny(lambdaExpression) {
        const rule = this.registerRule(new validation_1.CollectionValidationRule(lambdaExpression));
        return new builder_1.TypeValidatorBuilderImpl(rule);
    }
    /**
     * Entry point for defining validation rules that apply to each element (of type number) of an iterable.
     *
     * @param lambdaExpression
     * @returns {NumberValidatorBuilder}
     */
    validateIfEachNumber(lambdaExpression) {
        const rule = this.registerRule(new validation_1.CollectionValidationRule(lambdaExpression));
        return new builder_1.NumberValidatorBuilderImpl(rule);
    }
    /**
     * Entry point for defining validation rules that apply to each element (of type Date) of an iterable.
     *
     * @param lambdaExpression
     * @returns {DateValidatorBuilder}
     */
    validateIfEachDate(lambdaExpression) {
        const rule = this.registerRule(new validation_1.CollectionValidationRule(lambdaExpression));
        return new builder_1.DateValidatorBuilderImpl(rule);
    }
    /**
     * Entry point for defining validation rules that apply to each element (of type string) of an iterable.
     *
     * @param lambdaExpression
     * @returns {StringValidatorBuilder}
     */
    validateIfEachString(lambdaExpression) {
        const rule = this.registerRule(new validation_1.CollectionValidationRule(lambdaExpression));
        return new builder_1.StringValidatorBuilderImpl(rule);
    }
    validateIfIterable(lambdaExpression) {
        const rule = this.registerRule(new validation_1.ValidationRule(lambdaExpression));
        return new builder_1.SizedIterableValidatorBuilderImpl(rule);
    }
    registerRule(validationRule) {
        this.rules.push(validationRule);
        return validationRule;
    }
    /**
     * Synchronously validates the given input.
     *
     * Based on the rules defined in the constructor of the specific validator the validation is performed .
     *
     * @param input - the object to validate
     * @returns {ValidationResult}
     */
    validate(input) {
        const result = new shared_1.ValidationResult();
        this.rules.forEach((rule) => {
            const outcome = rule.apply(input);
            if (outcome.isFailure()) {
                result.addFailures(outcome.getValidationFailures());
            }
        });
        return result;
    }
    /**
     * Asynchronously validates the given input.
     *
     * Based on the rules defined in the constructor of the specific validator the validation is performed .
     *
     * @param input - the object to validate
     * @returns {Promise<ValidationResult>}
     */
    validateAsync(input) {
        return new Promise((resolve) => {
            const promises = this.createPromiseForEachRule(input, this.rules);
            Promise.all(promises).then((outcomes) => {
                resolve(this.buildValidationResultFrom(outcomes));
            });
        });
    }
    createPromiseForEachRule(input, rules) {
        const promises = [];
        rules.forEach((rule) => {
            promises.push(this.applyRuleAsync(rule, input));
        });
        return promises;
    }
    applyRuleAsync(rule, input) {
        return new Promise((resolve) => {
            resolve(rule.apply(input));
        });
    }
    buildValidationResultFrom(outcomes) {
        const result = new shared_1.ValidationResult();
        outcomes.forEach((outcome) => {
            if (outcome.isFailure()) {
                result.addFailures(outcome.getValidationFailures());
            }
        });
        return result;
    }
}
exports.AbstractValidator = AbstractValidator;
//# sourceMappingURL=AbstractValidator.js.map